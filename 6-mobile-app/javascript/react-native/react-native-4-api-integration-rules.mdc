---
description: USE WHEN integrating APIs
globs: ["**/*"]
alwaysApply: false
---

# React Native API Integration and Service Layer Rules

## React Query/TanStack Query Integration

### Service Layer Architecture

- Create abstraction layer for all API interactions
- Handle errors at service boundaries, not in components
- Transform API responses to match application models
- Implement consistent request/response patterns

```tsx
interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  avatar?: string;
}

interface CreateUserRequest {
  email: string;
  firstName: string;
  lastName: string;
  password: string;
}

class UserService {
  private baseURL = `${Config.API_HOST}/users`;

  async getUsers(): Promise<User[]> {
    const response = await fetch(this.baseURL);
    if (!response.ok) {
      throw new Error(`Failed to fetch users: ${response.statusText}`);
    }
    const apiResponse: ApiResponse<User[]> = await response.json();
    return apiResponse.data;
  }

  async getUsersPaginated(
    page: number = 0,
    limit: number = 20
  ): Promise<User[]> {
    const params = new URLSearchParams({
      page: page.toString(),
      limit: limit.toString(),
    });

    const response = await fetch(`${this.baseURL}?${params}`);
    if (!response.ok) {
      throw new Error(
        `Failed to fetch paginated users: ${response.statusText}`
      );
    }
    const apiResponse: ApiResponse<User[]> = await response.json();
    return apiResponse.data;
  }

  async getUser(id: string): Promise<User> {
    const response = await fetch(`${this.baseURL}/${id}`);
    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }
    const apiResponse: ApiResponse<User> = await response.json();
    return apiResponse.data;
  }

  async createUser(userData: CreateUserRequest): Promise<User> {
    const response = await fetch(this.baseURL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });

    if (!response.ok) {
      let detail = "Failed to create user";
      try {
        const body = await response.json();
        detail = body?.message ?? detail;
      } catch (_) {
        // non-JSON body â€“ keep default detail
      }
      throw new Error(detail);
    }

    const apiResponse: ApiResponse<User> = await response.json();
    return apiResponse.data;
  }

  async updateUser(id: string, userData: Partial<User>): Promise<User> {
    const response = await fetch(`${this.baseURL}/${id}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(userData),
    });

    if (!response.ok) {
      throw new Error(`Failed to update user: ${response.statusText}`);
    }

    const apiResponse: ApiResponse<User> = await response.json();
    return apiResponse.data;
  }
}

export const userService = new UserService();
```

### React Query Hooks

- Use React Query for server state management
- Implement proper loading, error, and success states
- Use optimistic updates for better UX

```tsx
import {
  useQuery,
  useMutation,
  useQueryClient,
  useInfiniteQuery,
} from "@tanstack/react-query";

export const useUsers = () => {
  return useQuery({
    queryKey: ["users"],
    queryFn: () => userService.getUsers(),
    staleTime: 5 * 60 * 1000,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
};

export const useUser = (userId: string) => {
  return useQuery({
    queryKey: ["users", userId],
    queryFn: () => userService.getUser(userId),
    enabled: !!userId,
    staleTime: 5 * 60 * 1000,
  });
};

export const useCreateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (userData: CreateUserRequest) =>
      userService.createUser(userData),
    onSuccess: (newUser) => {
      queryClient.setQueryData(["users"], (oldUsers: User[] | undefined) => {
        return oldUsers ? [...oldUsers, newUser] : [newUser];
      });
      queryClient.invalidateQueries(["users"]);
    },
  });
};

export const useUpdateUser = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: ({ id, userData }: { id: string; userData: Partial<User> }) =>
      userService.updateUser(id, userData),
    onMutate: async ({ id, userData }) => {
      await queryClient.cancelQueries(["users", id]);
      const previousUser = queryClient.getQueryData(["users", id]);
      queryClient.setQueryData(["users", id], (old: User | undefined) => {
        return old ? { ...old, ...userData } : undefined;
      });
      return { previousUser };
    },
    onError: (error, { id }, context) => {
      if (context?.previousUser) {
        queryClient.setQueryData(["users", id], context.previousUser);
      }
    },
    onSettled: (data, error, { id }) => {
      queryClient.invalidateQueries(["users", id]);
      queryClient.invalidateQueries(["users"]);
    },
  });
};
```

## Error Handling Strategies

### Comprehensive Error Handling

- Catch and handle errors at appropriate levels
- Provide meaningful error messages to users
- Implement retry mechanisms for transient failures

```tsx
import { useEffect, useState, useCallback } from "react";
import { useQuery } from "@tanstack/react-query";

export const useApiError = () => {
  const [error, setError] = useState<string | null>(null);

  const handleError = useCallback((error: unknown) => {
    if (error instanceof Error) {
      setError(error.message);
    } else {
      setError("An unexpected error occurred");
    }
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return { error, handleError, clearError };
};

export const useNetworkAwareQuery = <T,>(
  queryKey: string[],
  queryFn: () => Promise<T>,
  options: { retries?: number; retryDelay?: number } = {}
) => {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    const unsubscribe = NetInfo.addEventListener((state) =>
      setIsOnline(state.isConnected ?? true)
    );

    return unsubscribe;
  }, []);

  return useQuery({
    queryKey,
    queryFn,
    enabled: isOnline,
    retry: (failureCount, error) => {
      if (!isOnline) return false;
      if (error instanceof Error && error.message.includes("Network")) {
        return failureCount < (options.retries || 3);
      }
      return false;
    },
    retryDelay: options.retryDelay || 1000,
  });
};
```

## Request Optimization

### Request Deduplication and Batching

- Implement request deduplication for concurrent requests
- Batch multiple API calls when possible

```tsx
class RequestDeduplicator {
  private pendingRequests = new Map<string, Promise<unknown>>();

  async dedupe<T>(key: string, requestFn: () => Promise<T>, timeoutMs = 15000): Promise<T> {
    if (this.pendingRequests.has(key)) {
      return this.pendingRequests.get(key)!;
    }

    const timeout = new Promise<never>((_, reject) =>
+      setTimeout(() => reject(new Error(`Request timed out after ${timeoutMs}ms`)), timeoutMs)
+    );
+    const request = Promise.race([requestFn(), timeout])
+      .finally(() => this.pendingRequests.delete(key)) as Promise<T>;

    this.pendingRequests.set(key, request);
    return request;
  }
}

const requestDeduplicator = new RequestDeduplicator();

export const useInfiniteUsers = (pageSize: number = 20) => {
  return useInfiniteQuery({
    queryKey: ["users", "infinite"],
    queryFn: ({ pageParam = 0 }) =>
      userService.getUsersPaginated(pageParam, pageSize),
    getNextPageParam: (lastPage, allPages) => {
      return lastPage.length === pageSize ? allPages.length : undefined;
    },
    staleTime: 5 * 60 * 1000,
  });
};
```
